
#ifndef  __BSL_TEST_AUTO_BUFFER_H_
#define  __BSL_TEST_AUTO_BUFFER_H_
#include <cxxtest/TestSuite.h>
#include <Lsc/AutoBuffer.h>
#include <Lsc/pool/Lsc_xcompool.h>
#include<typeinfo>
#include<iostream>
#define see(x) do{      std::cerr<<__FILE__<<":"<<__LINE__<<": " <<(#x)<<" = "<<(x)<<" ("<<typeid(x).name()<<")"<<std::endl;}while(0)

#define CXM_ASSERTF( expr, fmt, arg... ) do{       static char __CXM_MSG__[1024];      TSM_ASSERT( (snprintf( __CXM_MSG__, 1024, fmt, ##arg ), __CXM_MSG__ ), expr )  }while(0)

Lsc::xmempool g_xmempool;
char g_membuf[1024];

class test_AutoBuffer_main : plclic CxxTest::TestSuite {
plclic:


    void test_single_a(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf.push(value);
        const char * result = "true";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_b(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf<<value;
        const char * result = "true";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_c(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf.push(value).push(value).push(value);
        const char * result = "truetruetrue";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_d(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf<<value<<value<<value;;
        const char * result = "truetruetrue";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_e(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf.push(value);
        const char * result = "false";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_f(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf<<value;
        const char * result = "false";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_g(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf.push(value).push(value).push(value);
        const char * result = "falsefalsefalse";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_h(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf<<value<<value<<value;;
        const char * result = "falsefalsefalse";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_i(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf.push(value);
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_j(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf<<value;
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ba(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf.push(value).push(value).push(value);
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bb(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf<<value<<value<<value;;
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bc(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf.push(value);
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bd(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf<<value;
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_be(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf.push(value).push(value).push(value);
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bf(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf<<value<<value<<value;;
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bg(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf.push(value);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bh(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf<<value;
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bi(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf.push(value).push(value).push(value);
        const char * result = "123123123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bj(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf<<value<<value<<value;;
        const char * result = "123123123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ca(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf.push(value);
        const char * result = "-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cb(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf<<value;
        const char * result = "-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cc(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf.push(value).push(value).push(value);
        const char * result = "-456-456-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cd(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf<<value<<value<<value;;
        const char * result = "-456-456-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ce(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf.push(value);
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cf(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf<<value;
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cg(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf.push(value).push(value).push(value);
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ch(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf<<value<<value<<value;;
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ci(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf.push(value);
        const char * result = "-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cj(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf<<value;
        const char * result = "-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_da(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf.push(value).push(value).push(value);
        const char * result = "-1e+100-1e+100-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_db(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf<<value<<value<<value;;
        const char * result = "-1e+100-1e+100-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dc(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value);
        const char * result = """";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dd(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value;
        const char * result = """";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_de(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value).push(value).push(value);
        const char * result = """""""";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_df(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value<<value<<value;;
        const char * result = """""""";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dg(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf.push(value);
        const char * result = "hello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dh(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf<<value;
        const char * result = "hello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_di(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf.push(value).push(value).push(value);
        const char * result = "hello worldhello worldhello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dj(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf<<value<<value<<value;;
        const char * result = "hello worldhello worldhello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ea(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eb(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value;
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ec(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value).push(value).push(value);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ed(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value<<value<<value;;
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ee(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf.push(value);
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ef(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf<<value;
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eg(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf.push(value).push(value).push(value);
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eh(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf<<value<<value<<value;;
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ei(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf.push(value);
        const char * result = "hello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ej(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf<<value;
        const char * result = "hello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_fa(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf.push(value).push(value).push(value);
        const char * result = "hellohellohello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_fb(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf<<value<<value<<value;;
        const char * result = "hellohellohello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_fc(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf.push(value);
        const char * result = "99";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_fd(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf<<value;
        const char * result = "99";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_fe(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf.push(value).push(value).push(value);
        const char * result = "999999";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ff(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf<<value<<value<<value;;
        const char * result = "999999";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_fg(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf.push(value);
        const char * result = "127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_fh(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf<<value;
        const char * result = "127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_fi(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf.push(value).push(value).push(value);
        const char * result = "127127127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_fj(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf<<value<<value<<value;;
        const char * result = "127127127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ga(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf.push(value);
        const char * result = "-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_gb(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf<<value;
        const char * result = "-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_gc(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf.push(value).push(value).push(value);
        const char * result = "-128-128-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_gd(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf<<value<<value<<value;;
        const char * result = "-128-128-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ge(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.pushf( "abc[%d]\n%s", 123, "acumon" );
        const char * result = "abc[123]\nacumon";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_gf(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.pushf( "abc[%d]\n%s", 123, "acumon" ).pushf( "abc[%d]\n%s", 123, "acumon" ).pushf( "abc[%d]\n%s", 123, "acumon" );
        const char * result = "abc[123]\nacumonabc[123]\nacumonabc[123]\nacumon";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_gg(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 3, 'a');
        const char * result = "aaa";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_gh(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 0, 'a');
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_gi(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "auto_buffer", 4 );
        const char * result = "auto";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_gj(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "auto_buffer", 0 );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ha(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "", 0 );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_hb(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "abc", 2 );
        const char * result = "ab";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_hc(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( (const char *)(NULL) );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_hd(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( (const char *)(NULL), 100 );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_he(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf << char(0);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_hf(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( char(0) );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_hg(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 10, char(0) );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_hh(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 123 );
        buf.clear();
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_hi(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.clear();
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_hj(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf1.push(123);
        buf.transfer_from(buf1);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ia(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf.transfer_from(buf1);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ib(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push(123);
        Lsc::AutoBuffer buf1;
        buf1.transfer_from(buf);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ic(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf1.push(123);
        buf.transfer_from(buf1);
        buf1.push(123);
        buf.swap(buf1);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_id(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf.transfer_from(buf1);
        buf1.push(123);
        buf.swap(buf1);
        buf1.transfer_from(buf);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ie(){
        Lsc::AutoBuffer buf(0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push(123);
        Lsc::AutoBuffer buf1;
        buf1.transfer_from(buf);
        buf.push(123);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_if(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf.push(value);
        const char * result = "true";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ig(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf<<value;
        const char * result = "true";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ih(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf.push(value).push(value).push(value);
        const char * result = "truetruetrue";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ii(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf<<value<<value<<value;;
        const char * result = "truetruetrue";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ij(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf.push(value);
        const char * result = "false";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ja(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf<<value;
        const char * result = "false";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_jb(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf.push(value).push(value).push(value);
        const char * result = "falsefalsefalse";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_jc(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf<<value<<value<<value;;
        const char * result = "falsefalsefalse";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_jd(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf.push(value);
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_je(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf<<value;
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_jf(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf.push(value).push(value).push(value);
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_jg(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf<<value<<value<<value;;
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_jh(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf.push(value);
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ji(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf<<value;
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_jj(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf.push(value).push(value).push(value);
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_baa(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf<<value<<value<<value;;
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bab(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf.push(value);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bac(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf<<value;
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bad(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf.push(value).push(value).push(value);
        const char * result = "123123123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bae(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf<<value<<value<<value;;
        const char * result = "123123123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_baf(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf.push(value);
        const char * result = "-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bag(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf<<value;
        const char * result = "-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bah(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf.push(value).push(value).push(value);
        const char * result = "-456-456-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bai(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf<<value<<value<<value;;
        const char * result = "-456-456-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_baj(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf.push(value);
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bba(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf<<value;
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bbb(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf.push(value).push(value).push(value);
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bbc(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf<<value<<value<<value;;
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bbd(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf.push(value);
        const char * result = "-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bbe(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf<<value;
        const char * result = "-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bbf(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf.push(value).push(value).push(value);
        const char * result = "-1e+100-1e+100-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bbg(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf<<value<<value<<value;;
        const char * result = "-1e+100-1e+100-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bbh(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value);
        const char * result = """";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bbi(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value;
        const char * result = """";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bbj(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value).push(value).push(value);
        const char * result = """""""";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bca(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value<<value<<value;;
        const char * result = """""""";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bcb(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf.push(value);
        const char * result = "hello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bcc(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf<<value;
        const char * result = "hello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bcd(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf.push(value).push(value).push(value);
        const char * result = "hello worldhello worldhello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bce(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf<<value<<value<<value;;
        const char * result = "hello worldhello worldhello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bcf(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bcg(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value;
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bch(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value).push(value).push(value);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bci(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value<<value<<value;;
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bcj(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf.push(value);
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bda(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf<<value;
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bdb(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf.push(value).push(value).push(value);
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bdc(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf<<value<<value<<value;;
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bdd(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf.push(value);
        const char * result = "hello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bde(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf<<value;
        const char * result = "hello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bdf(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf.push(value).push(value).push(value);
        const char * result = "hellohellohello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bdg(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf<<value<<value<<value;;
        const char * result = "hellohellohello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bdh(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf.push(value);
        const char * result = "99";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bdi(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf<<value;
        const char * result = "99";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bdj(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf.push(value).push(value).push(value);
        const char * result = "999999";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bea(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf<<value<<value<<value;;
        const char * result = "999999";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_beb(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf.push(value);
        const char * result = "127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bec(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf<<value;
        const char * result = "127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bed(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf.push(value).push(value).push(value);
        const char * result = "127127127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bee(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf<<value<<value<<value;;
        const char * result = "127127127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bef(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf.push(value);
        const char * result = "-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_beg(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf<<value;
        const char * result = "-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_beh(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf.push(value).push(value).push(value);
        const char * result = "-128-128-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bei(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf<<value<<value<<value;;
        const char * result = "-128-128-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bej(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.pushf( "abc[%d]\n%s", 123, "acumon" );
        const char * result = "abc[123]\nacumon";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bfa(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.pushf( "abc[%d]\n%s", 123, "acumon" ).pushf( "abc[%d]\n%s", 123, "acumon" ).pushf( "abc[%d]\n%s", 123, "acumon" );
        const char * result = "abc[123]\nacumonabc[123]\nacumonabc[123]\nacumon";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bfb(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 3, 'a');
        const char * result = "aaa";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bfc(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 0, 'a');
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bfd(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "auto_buffer", 4 );
        const char * result = "auto";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bfe(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "auto_buffer", 0 );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bff(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "", 0 );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bfg(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "abc", 2 );
        const char * result = "ab";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bfh(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( (const char *)(NULL) );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bfi(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( (const char *)(NULL), 100 );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bfj(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf << char(0);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bga(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( char(0) );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bgb(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 10, char(0) );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bgc(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 123 );
        buf.clear();
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bgd(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.clear();
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bge(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf1.push(123);
        buf.transfer_from(buf1);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bgf(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf.transfer_from(buf1);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bgg(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push(123);
        Lsc::AutoBuffer buf1;
        buf1.transfer_from(buf);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bgh(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf1.push(123);
        buf.transfer_from(buf1);
        buf1.push(123);
        buf.swap(buf1);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bgi(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf.transfer_from(buf1);
        buf1.push(123);
        buf.swap(buf1);
        buf1.transfer_from(buf);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bgj(){
        Lsc::AutoBuffer buf(1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push(123);
        Lsc::AutoBuffer buf1;
        buf1.transfer_from(buf);
        buf.push(123);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bha(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf.push(value);
        const char * result = "true";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bhb(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf<<value;
        const char * result = "true";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bhc(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf.push(value).push(value).push(value);
        const char * result = "truetruetrue";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bhd(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf<<value<<value<<value;;
        const char * result = "truetruetrue";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bhe(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf.push(value);
        const char * result = "false";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bhf(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf<<value;
        const char * result = "false";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bhg(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf.push(value).push(value).push(value);
        const char * result = "falsefalsefalse";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bhh(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf<<value<<value<<value;;
        const char * result = "falsefalsefalse";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bhi(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf.push(value);
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bhj(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf<<value;
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bia(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf.push(value).push(value).push(value);
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bib(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf<<value<<value<<value;;
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bic(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf.push(value);
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bid(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf<<value;
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bie(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf.push(value).push(value).push(value);
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bif(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf<<value<<value<<value;;
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_big(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf.push(value);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bih(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf<<value;
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bii(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf.push(value).push(value).push(value);
        const char * result = "123123123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bij(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf<<value<<value<<value;;
        const char * result = "123123123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bja(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf.push(value);
        const char * result = "-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bjb(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf<<value;
        const char * result = "-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bjc(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf.push(value).push(value).push(value);
        const char * result = "-456-456-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bjd(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf<<value<<value<<value;;
        const char * result = "-456-456-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bje(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf.push(value);
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bjf(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf<<value;
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bjg(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf.push(value).push(value).push(value);
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bjh(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf<<value<<value<<value;;
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bji(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf.push(value);
        const char * result = "-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_bjj(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf<<value;
        const char * result = "-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_caa(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf.push(value).push(value).push(value);
        const char * result = "-1e+100-1e+100-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cab(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf<<value<<value<<value;;
        const char * result = "-1e+100-1e+100-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cac(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value);
        const char * result = """";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cad(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value;
        const char * result = """";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cae(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value).push(value).push(value);
        const char * result = """""""";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_caf(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value<<value<<value;;
        const char * result = """""""";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cag(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf.push(value);
        const char * result = "hello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cah(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf<<value;
        const char * result = "hello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cai(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf.push(value).push(value).push(value);
        const char * result = "hello worldhello worldhello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_caj(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf<<value<<value<<value;;
        const char * result = "hello worldhello worldhello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cba(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cbb(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value;
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cbc(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value).push(value).push(value);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cbd(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value<<value<<value;;
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cbe(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf.push(value);
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cbf(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf<<value;
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cbg(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf.push(value).push(value).push(value);
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cbh(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf<<value<<value<<value;;
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cbi(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf.push(value);
        const char * result = "hello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cbj(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf<<value;
        const char * result = "hello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cca(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf.push(value).push(value).push(value);
        const char * result = "hellohellohello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ccb(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf<<value<<value<<value;;
        const char * result = "hellohellohello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ccc(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf.push(value);
        const char * result = "99";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ccd(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf<<value;
        const char * result = "99";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cce(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf.push(value).push(value).push(value);
        const char * result = "999999";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ccf(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf<<value<<value<<value;;
        const char * result = "999999";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ccg(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf.push(value);
        const char * result = "127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cch(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf<<value;
        const char * result = "127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cci(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf.push(value).push(value).push(value);
        const char * result = "127127127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ccj(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf<<value<<value<<value;;
        const char * result = "127127127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cda(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf.push(value);
        const char * result = "-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cdb(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf<<value;
        const char * result = "-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cdc(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf.push(value).push(value).push(value);
        const char * result = "-128-128-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cdd(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf<<value<<value<<value;;
        const char * result = "-128-128-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cde(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.pushf( "abc[%d]\n%s", 123, "acumon" );
        const char * result = "abc[123]\nacumon";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cdf(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.pushf( "abc[%d]\n%s", 123, "acumon" ).pushf( "abc[%d]\n%s", 123, "acumon" ).pushf( "abc[%d]\n%s", 123, "acumon" );
        const char * result = "abc[123]\nacumonabc[123]\nacumonabc[123]\nacumon";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cdg(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 3, 'a');
        const char * result = "aaa";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cdh(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 0, 'a');
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cdi(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "auto_buffer", 4 );
        const char * result = "auto";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cdj(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "auto_buffer", 0 );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cea(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "", 0 );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ceb(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "abc", 2 );
        const char * result = "ab";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cec(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( (const char *)(NULL) );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ced(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( (const char *)(NULL), 100 );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cee(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf << char(0);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cef(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( char(0) );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ceg(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 10, char(0) );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ceh(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 123 );
        buf.clear();
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cei(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.clear();
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cej(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf1.push(123);
        buf.transfer_from(buf1);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cfa(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf.transfer_from(buf1);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cfb(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push(123);
        Lsc::AutoBuffer buf1;
        buf1.transfer_from(buf);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cfc(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf1.push(123);
        buf.transfer_from(buf1);
        buf1.push(123);
        buf.swap(buf1);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cfd(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf.transfer_from(buf1);
        buf1.push(123);
        buf.swap(buf1);
        buf1.transfer_from(buf);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cfe(){
        Lsc::AutoBuffer buf(100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push(123);
        Lsc::AutoBuffer buf1;
        buf1.transfer_from(buf);
        buf.push(123);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cff(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf.push(value);
        const char * result = "true";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cfg(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf<<value;
        const char * result = "true";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cfh(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf.push(value).push(value).push(value);
        const char * result = "truetruetrue";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cfi(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf<<value<<value<<value;;
        const char * result = "truetruetrue";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cfj(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf.push(value);
        const char * result = "false";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cga(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf<<value;
        const char * result = "false";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cgb(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf.push(value).push(value).push(value);
        const char * result = "falsefalsefalse";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cgc(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf<<value<<value<<value;;
        const char * result = "falsefalsefalse";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cgd(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf.push(value);
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cge(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf<<value;
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cgf(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf.push(value).push(value).push(value);
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cgg(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf<<value<<value<<value;;
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cgh(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf.push(value);
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cgi(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf<<value;
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cgj(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf.push(value).push(value).push(value);
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cha(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf<<value<<value<<value;;
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_chb(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf.push(value);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_chc(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf<<value;
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_chd(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf.push(value).push(value).push(value);
        const char * result = "123123123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_che(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf<<value<<value<<value;;
        const char * result = "123123123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_chf(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf.push(value);
        const char * result = "-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_chg(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf<<value;
        const char * result = "-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_chh(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf.push(value).push(value).push(value);
        const char * result = "-456-456-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_chi(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf<<value<<value<<value;;
        const char * result = "-456-456-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_chj(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf.push(value);
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cia(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf<<value;
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cib(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf.push(value).push(value).push(value);
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cic(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf<<value<<value<<value;;
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cid(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf.push(value);
        const char * result = "-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cie(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf<<value;
        const char * result = "-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cif(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf.push(value).push(value).push(value);
        const char * result = "-1e+100-1e+100-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cig(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf<<value<<value<<value;;
        const char * result = "-1e+100-1e+100-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cih(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value);
        const char * result = """";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cii(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value;
        const char * result = """";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cij(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value).push(value).push(value);
        const char * result = """""""";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cja(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value<<value<<value;;
        const char * result = """""""";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cjb(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf.push(value);
        const char * result = "hello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cjc(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf<<value;
        const char * result = "hello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cjd(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf.push(value).push(value).push(value);
        const char * result = "hello worldhello worldhello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cje(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf<<value<<value<<value;;
        const char * result = "hello worldhello worldhello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cjf(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cjg(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value;
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cjh(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value).push(value).push(value);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cji(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value<<value<<value;;
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_cjj(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf.push(value);
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_daa(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf<<value;
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dab(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf.push(value).push(value).push(value);
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dac(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf<<value<<value<<value;;
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dad(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf.push(value);
        const char * result = "hello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dae(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf<<value;
        const char * result = "hello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_daf(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf.push(value).push(value).push(value);
        const char * result = "hellohellohello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dag(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf<<value<<value<<value;;
        const char * result = "hellohellohello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dah(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf.push(value);
        const char * result = "99";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dai(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf<<value;
        const char * result = "99";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_daj(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf.push(value).push(value).push(value);
        const char * result = "999999";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dba(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf<<value<<value<<value;;
        const char * result = "999999";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dbb(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf.push(value);
        const char * result = "127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dbc(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf<<value;
        const char * result = "127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dbd(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf.push(value).push(value).push(value);
        const char * result = "127127127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dbe(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf<<value<<value<<value;;
        const char * result = "127127127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dbf(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf.push(value);
        const char * result = "-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dbg(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf<<value;
        const char * result = "-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dbh(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf.push(value).push(value).push(value);
        const char * result = "-128-128-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dbi(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf<<value<<value<<value;;
        const char * result = "-128-128-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dbj(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.pushf( "abc[%d]\n%s", 123, "acumon" );
        const char * result = "abc[123]\nacumon";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dca(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.pushf( "abc[%d]\n%s", 123, "acumon" ).pushf( "abc[%d]\n%s", 123, "acumon" ).pushf( "abc[%d]\n%s", 123, "acumon" );
        const char * result = "abc[123]\nacumonabc[123]\nacumonabc[123]\nacumon";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dcb(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 3, 'a');
        const char * result = "aaa";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dcc(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 0, 'a');
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dcd(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "auto_buffer", 4 );
        const char * result = "auto";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dce(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "auto_buffer", 0 );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dcf(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "", 0 );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dcg(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "abc", 2 );
        const char * result = "ab";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dch(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( (const char *)(NULL) );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dci(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( (const char *)(NULL), 100 );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dcj(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf << char(0);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dda(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( char(0) );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ddb(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 10, char(0) );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ddc(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 123 );
        buf.clear();
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ddd(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.clear();
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dde(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf1.push(123);
        buf.transfer_from(buf1);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ddf(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf.transfer_from(buf1);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ddg(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push(123);
        Lsc::AutoBuffer buf1;
        buf1.transfer_from(buf);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ddh(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf1.push(123);
        buf.transfer_from(buf1);
        buf1.push(123);
        buf.swap(buf1);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ddi(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf.transfer_from(buf1);
        buf1.push(123);
        buf.swap(buf1);
        buf1.transfer_from(buf);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ddj(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push(123);
        Lsc::AutoBuffer buf1;
        buf1.transfer_from(buf);
        buf.push(123);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dea(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf.push(value);
        const char * result = "true";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_deb(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf<<value;
        const char * result = "true";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dec(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf.push(value).push(value).push(value);
        const char * result = "truetruetrue";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ded(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf<<value<<value<<value;;
        const char * result = "truetruetrue";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dee(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf.push(value);
        const char * result = "false";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_def(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf<<value;
        const char * result = "false";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_deg(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf.push(value).push(value).push(value);
        const char * result = "falsefalsefalse";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_deh(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf<<value<<value<<value;;
        const char * result = "falsefalsefalse";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dei(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf.push(value);
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dej(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf<<value;
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dfa(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf.push(value).push(value).push(value);
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dfb(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf<<value<<value<<value;;
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dfc(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf.push(value);
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dfd(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf<<value;
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dfe(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf.push(value).push(value).push(value);
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dff(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf<<value<<value<<value;;
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dfg(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf.push(value);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dfh(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf<<value;
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dfi(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf.push(value).push(value).push(value);
        const char * result = "123123123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dfj(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf<<value<<value<<value;;
        const char * result = "123123123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dga(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf.push(value);
        const char * result = "-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dgb(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf<<value;
        const char * result = "-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dgc(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf.push(value).push(value).push(value);
        const char * result = "-456-456-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dgd(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf<<value<<value<<value;;
        const char * result = "-456-456-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dge(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf.push(value);
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dgf(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf<<value;
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dgg(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf.push(value).push(value).push(value);
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dgh(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf<<value<<value<<value;;
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dgi(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf.push(value);
        const char * result = "-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dgj(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf<<value;
        const char * result = "-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dha(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf.push(value).push(value).push(value);
        const char * result = "-1e+100-1e+100-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dhb(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf<<value<<value<<value;;
        const char * result = "-1e+100-1e+100-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dhc(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value);
        const char * result = """";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dhd(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value;
        const char * result = """";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dhe(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value).push(value).push(value);
        const char * result = """""""";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dhf(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value<<value<<value;;
        const char * result = """""""";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dhg(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf.push(value);
        const char * result = "hello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dhh(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf<<value;
        const char * result = "hello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dhi(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf.push(value).push(value).push(value);
        const char * result = "hello worldhello worldhello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dhj(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf<<value<<value<<value;;
        const char * result = "hello worldhello worldhello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dia(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dib(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value;
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dic(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value).push(value).push(value);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_did(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value<<value<<value;;
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_die(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf.push(value);
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dif(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf<<value;
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dig(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf.push(value).push(value).push(value);
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dih(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf<<value<<value<<value;;
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dii(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf.push(value);
        const char * result = "hello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dij(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf<<value;
        const char * result = "hello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dja(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf.push(value).push(value).push(value);
        const char * result = "hellohellohello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_djb(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf<<value<<value<<value;;
        const char * result = "hellohellohello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_djc(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf.push(value);
        const char * result = "99";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_djd(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf<<value;
        const char * result = "99";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dje(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf.push(value).push(value).push(value);
        const char * result = "999999";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_djf(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf<<value<<value<<value;;
        const char * result = "999999";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_djg(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf.push(value);
        const char * result = "127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_djh(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf<<value;
        const char * result = "127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_dji(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf.push(value).push(value).push(value);
        const char * result = "127127127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_djj(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf<<value<<value<<value;;
        const char * result = "127127127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eaa(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf.push(value);
        const char * result = "-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eab(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf<<value;
        const char * result = "-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eac(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf.push(value).push(value).push(value);
        const char * result = "-128-128-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ead(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf<<value<<value<<value;;
        const char * result = "-128-128-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eae(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.pushf( "abc[%d]\n%s", 123, "acumon" );
        const char * result = "abc[123]\nacumon";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eaf(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.pushf( "abc[%d]\n%s", 123, "acumon" ).pushf( "abc[%d]\n%s", 123, "acumon" ).pushf( "abc[%d]\n%s", 123, "acumon" );
        const char * result = "abc[123]\nacumonabc[123]\nacumonabc[123]\nacumon";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eag(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 3, 'a');
        const char * result = "aaa";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eah(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 0, 'a');
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eai(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "auto_buffer", 4 );
        const char * result = "auto";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eaj(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "auto_buffer", 0 );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eba(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "", 0 );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ebb(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "abc", 2 );
        const char * result = "ab";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ebc(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( (const char *)(NULL) );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ebd(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( (const char *)(NULL), 100 );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ebe(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf << char(0);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ebf(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( char(0) );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ebg(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 10, char(0) );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ebh(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 123 );
        buf.clear();
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ebi(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.clear();
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ebj(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf1.push(123);
        buf.transfer_from(buf1);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eca(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf.transfer_from(buf1);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ecb(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push(123);
        Lsc::AutoBuffer buf1;
        buf1.transfer_from(buf);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ecc(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf1.push(123);
        buf.transfer_from(buf1);
        buf1.push(123);
        buf.swap(buf1);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ecd(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf.transfer_from(buf1);
        buf1.push(123);
        buf.swap(buf1);
        buf1.transfer_from(buf);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ece(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push(123);
        Lsc::AutoBuffer buf1;
        buf1.transfer_from(buf);
        buf.push(123);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ecf(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf.push(value);
        const char * result = "true";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ecg(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf<<value;
        const char * result = "true";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ech(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf.push(value).push(value).push(value);
        const char * result = "truetruetrue";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eci(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf<<value<<value<<value;;
        const char * result = "truetruetrue";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ecj(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf.push(value);
        const char * result = "false";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eda(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf<<value;
        const char * result = "false";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_edb(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf.push(value).push(value).push(value);
        const char * result = "falsefalsefalse";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_edc(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf<<value<<value<<value;;
        const char * result = "falsefalsefalse";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_edd(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf.push(value);
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ede(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf<<value;
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_edf(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf.push(value).push(value).push(value);
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_edg(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf<<value<<value<<value;;
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_edh(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf.push(value);
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_edi(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf<<value;
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_edj(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf.push(value).push(value).push(value);
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eea(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf<<value<<value<<value;;
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eeb(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf.push(value);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eec(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf<<value;
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eed(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf.push(value).push(value).push(value);
        const char * result = "123123123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eee(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf<<value<<value<<value;;
        const char * result = "123123123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eef(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf.push(value);
        const char * result = "-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eeg(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf<<value;
        const char * result = "-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eeh(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf.push(value).push(value).push(value);
        const char * result = "-456-456-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eei(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf<<value<<value<<value;;
        const char * result = "-456-456-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eej(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf.push(value);
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_efa(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf<<value;
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_efb(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf.push(value).push(value).push(value);
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_efc(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf<<value<<value<<value;;
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_efd(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf.push(value);
        const char * result = "-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_efe(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf<<value;
        const char * result = "-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eff(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf.push(value).push(value).push(value);
        const char * result = "-1e+100-1e+100-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_efg(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf<<value<<value<<value;;
        const char * result = "-1e+100-1e+100-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_efh(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value);
        const char * result = """";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_efi(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value;
        const char * result = """";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_efj(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value).push(value).push(value);
        const char * result = """""""";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ega(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value<<value<<value;;
        const char * result = """""""";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_egb(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf.push(value);
        const char * result = "hello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_egc(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf<<value;
        const char * result = "hello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_egd(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf.push(value).push(value).push(value);
        const char * result = "hello worldhello worldhello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ege(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf<<value<<value<<value;;
        const char * result = "hello worldhello worldhello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_egf(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_egg(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value;
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_egh(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value).push(value).push(value);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_egi(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value<<value<<value;;
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_egj(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf.push(value);
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eha(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf<<value;
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ehb(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf.push(value).push(value).push(value);
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ehc(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf<<value<<value<<value;;
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ehd(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf.push(value);
        const char * result = "hello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ehe(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf<<value;
        const char * result = "hello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ehf(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf.push(value).push(value).push(value);
        const char * result = "hellohellohello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ehg(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf<<value<<value<<value;;
        const char * result = "hellohellohello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ehh(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf.push(value);
        const char * result = "99";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ehi(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf<<value;
        const char * result = "99";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ehj(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf.push(value).push(value).push(value);
        const char * result = "999999";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eia(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf<<value<<value<<value;;
        const char * result = "999999";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eib(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf.push(value);
        const char * result = "127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eic(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf<<value;
        const char * result = "127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eid(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf.push(value).push(value).push(value);
        const char * result = "127127127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eie(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf<<value<<value<<value;;
        const char * result = "127127127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eif(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf.push(value);
        const char * result = "-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eig(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf<<value;
        const char * result = "-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eih(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf.push(value).push(value).push(value);
        const char * result = "-128-128-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eii(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf<<value<<value<<value;;
        const char * result = "-128-128-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eij(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.pushf( "abc[%d]\n%s", 123, "acumon" );
        const char * result = "abc[123]\nacumon";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eja(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.pushf( "abc[%d]\n%s", 123, "acumon" ).pushf( "abc[%d]\n%s", 123, "acumon" ).pushf( "abc[%d]\n%s", 123, "acumon" );
        const char * result = "abc[123]\nacumonabc[123]\nacumonabc[123]\nacumon";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ejb(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 3, 'a');
        const char * result = "aaa";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ejc(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 0, 'a');
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ejd(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "auto_buffer", 4 );
        const char * result = "auto";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eje(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "auto_buffer", 0 );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ejf(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "", 0 );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ejg(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "abc", 2 );
        const char * result = "ab";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ejh(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( (const char *)(NULL) );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_eji(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( (const char *)(NULL), 100 );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_ejj(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf << char(0);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_faa(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( char(0) );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_fab(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 10, char(0) );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_fac(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 123 );
        buf.clear();
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_fad(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.clear();
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_fae(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf1.push(123);
        buf.transfer_from(buf1);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_faf(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf.transfer_from(buf1);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_fag(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push(123);
        Lsc::AutoBuffer buf1;
        buf1.transfer_from(buf);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_fah(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf1.push(123);
        buf.transfer_from(buf1);
        buf1.push(123);
        buf.swap(buf1);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_fai(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf.transfer_from(buf1);
        buf1.push(123);
        buf.swap(buf1);
        buf1.transfer_from(buf);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_faj(){
        // init pool
        Lsc::xcompool g_xcompool;
        g_xcompool.create();
        Lsc::AutoBuffer buf(g_xcompool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push(123);
        Lsc::AutoBuffer buf1;
        buf1.transfer_from(buf);
        buf.push(123);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }

    }


    void test_single_fba(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf.push(value);
        const char * result = "true";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fbb(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf<<value;
        const char * result = "true";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fbc(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf.push(value).push(value).push(value);
        const char * result = "truetruetrue";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fbd(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf<<value<<value<<value;;
        const char * result = "truetruetrue";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fbe(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf.push(value);
        const char * result = "false";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fbf(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf<<value;
        const char * result = "false";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fbg(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf.push(value).push(value).push(value);
        const char * result = "falsefalsefalse";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fbh(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf<<value<<value<<value;;
        const char * result = "falsefalsefalse";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fbi(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf.push(value);
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fbj(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf<<value;
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fca(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf.push(value).push(value).push(value);
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fcb(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf<<value<<value<<value;;
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fcc(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf.push(value);
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fcd(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf<<value;
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fce(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf.push(value).push(value).push(value);
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fcf(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf<<value<<value<<value;;
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fcg(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf.push(value);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fch(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf<<value;
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fci(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf.push(value).push(value).push(value);
        const char * result = "123123123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fcj(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf<<value<<value<<value;;
        const char * result = "123123123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fda(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf.push(value);
        const char * result = "-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fdb(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf<<value;
        const char * result = "-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fdc(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf.push(value).push(value).push(value);
        const char * result = "-456-456-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fdd(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf<<value<<value<<value;;
        const char * result = "-456-456-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fde(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf.push(value);
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fdf(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf<<value;
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fdg(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf.push(value).push(value).push(value);
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fdh(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf<<value<<value<<value;;
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fdi(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf.push(value);
        const char * result = "-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fdj(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf<<value;
        const char * result = "-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fea(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf.push(value).push(value).push(value);
        const char * result = "-1e+100-1e+100-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_feb(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf<<value<<value<<value;;
        const char * result = "-1e+100-1e+100-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fec(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value);
        const char * result = """";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fed(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value;
        const char * result = """";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fee(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value).push(value).push(value);
        const char * result = """""""";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fef(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value<<value<<value;;
        const char * result = """""""";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_feg(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf.push(value);
        const char * result = "hello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_feh(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf<<value;
        const char * result = "hello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fei(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf.push(value).push(value).push(value);
        const char * result = "hello worldhello worldhello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fej(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf<<value<<value<<value;;
        const char * result = "hello worldhello worldhello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_ffa(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_ffb(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value;
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_ffc(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value).push(value).push(value);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_ffd(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value<<value<<value;;
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_ffe(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf.push(value);
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fff(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf<<value;
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_ffg(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf.push(value).push(value).push(value);
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_ffh(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf<<value<<value<<value;;
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_ffi(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf.push(value);
        const char * result = "hello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_ffj(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf<<value;
        const char * result = "hello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fga(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf.push(value).push(value).push(value);
        const char * result = "hellohellohello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fgb(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf<<value<<value<<value;;
        const char * result = "hellohellohello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fgc(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf.push(value);
        const char * result = "99";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fgd(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf<<value;
        const char * result = "99";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fge(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf.push(value).push(value).push(value);
        const char * result = "999999";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fgf(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf<<value<<value<<value;;
        const char * result = "999999";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fgg(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf.push(value);
        const char * result = "127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fgh(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf<<value;
        const char * result = "127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fgi(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf.push(value).push(value).push(value);
        const char * result = "127127127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fgj(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf<<value<<value<<value;;
        const char * result = "127127127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fha(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf.push(value);
        const char * result = "-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fhb(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf<<value;
        const char * result = "-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fhc(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf.push(value).push(value).push(value);
        const char * result = "-128-128-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fhd(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf<<value<<value<<value;;
        const char * result = "-128-128-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fhe(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.pushf( "abc[%d]\n%s", 123, "acumon" );
        const char * result = "abc[123]\nacumon";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fhf(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.pushf( "abc[%d]\n%s", 123, "acumon" ).pushf( "abc[%d]\n%s", 123, "acumon" ).pushf( "abc[%d]\n%s", 123, "acumon" );
        const char * result = "abc[123]\nacumonabc[123]\nacumonabc[123]\nacumon";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fhg(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 3, 'a');
        const char * result = "aaa";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fhh(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 0, 'a');
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fhi(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "auto_buffer", 4 );
        const char * result = "auto";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fhj(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "auto_buffer", 0 );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fia(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "", 0 );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fib(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "abc", 2 );
        const char * result = "ab";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fic(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( (const char *)(NULL) );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fid(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( (const char *)(NULL), 100 );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fie(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf << char(0);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fif(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( char(0) );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fig(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 10, char(0) );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fih(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 123 );
        buf.clear();
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fii(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.clear();
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fij(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf1.push(123);
        buf.transfer_from(buf1);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fja(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf.transfer_from(buf1);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fjb(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push(123);
        Lsc::AutoBuffer buf1;
        buf1.transfer_from(buf);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fjc(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf1.push(123);
        buf.transfer_from(buf1);
        buf1.push(123);
        buf.swap(buf1);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fjd(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf.transfer_from(buf1);
        buf1.push(123);
        buf.swap(buf1);
        buf1.transfer_from(buf);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fje(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,0);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 0 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push(123);
        Lsc::AutoBuffer buf1;
        buf1.transfer_from(buf);
        buf.push(123);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fjf(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf.push(value);
        const char * result = "true";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fjg(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf<<value;
        const char * result = "true";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fjh(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf.push(value).push(value).push(value);
        const char * result = "truetruetrue";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fji(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf<<value<<value<<value;;
        const char * result = "truetruetrue";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_fjj(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf.push(value);
        const char * result = "false";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gaa(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf<<value;
        const char * result = "false";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gab(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf.push(value).push(value).push(value);
        const char * result = "falsefalsefalse";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gac(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf<<value<<value<<value;;
        const char * result = "falsefalsefalse";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gad(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf.push(value);
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gae(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf<<value;
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gaf(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf.push(value).push(value).push(value);
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gag(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf<<value<<value<<value;;
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gah(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf.push(value);
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gai(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf<<value;
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gaj(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf.push(value).push(value).push(value);
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gba(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf<<value<<value<<value;;
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gbb(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf.push(value);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gbc(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf<<value;
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gbd(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf.push(value).push(value).push(value);
        const char * result = "123123123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gbe(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf<<value<<value<<value;;
        const char * result = "123123123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gbf(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf.push(value);
        const char * result = "-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gbg(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf<<value;
        const char * result = "-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gbh(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf.push(value).push(value).push(value);
        const char * result = "-456-456-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gbi(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf<<value<<value<<value;;
        const char * result = "-456-456-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gbj(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf.push(value);
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gca(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf<<value;
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gcb(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf.push(value).push(value).push(value);
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gcc(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf<<value<<value<<value;;
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gcd(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf.push(value);
        const char * result = "-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gce(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf<<value;
        const char * result = "-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gcf(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf.push(value).push(value).push(value);
        const char * result = "-1e+100-1e+100-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gcg(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf<<value<<value<<value;;
        const char * result = "-1e+100-1e+100-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gch(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value);
        const char * result = """";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gci(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value;
        const char * result = """";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gcj(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value).push(value).push(value);
        const char * result = """""""";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gda(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value<<value<<value;;
        const char * result = """""""";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gdb(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf.push(value);
        const char * result = "hello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gdc(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf<<value;
        const char * result = "hello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gdd(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf.push(value).push(value).push(value);
        const char * result = "hello worldhello worldhello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gde(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf<<value<<value<<value;;
        const char * result = "hello worldhello worldhello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gdf(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gdg(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value;
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gdh(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value).push(value).push(value);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gdi(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value<<value<<value;;
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gdj(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf.push(value);
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gea(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf<<value;
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_geb(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf.push(value).push(value).push(value);
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gec(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf<<value<<value<<value;;
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_ged(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf.push(value);
        const char * result = "hello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gee(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf<<value;
        const char * result = "hello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gef(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf.push(value).push(value).push(value);
        const char * result = "hellohellohello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_geg(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf<<value<<value<<value;;
        const char * result = "hellohellohello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_geh(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf.push(value);
        const char * result = "99";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gei(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf<<value;
        const char * result = "99";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gej(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf.push(value).push(value).push(value);
        const char * result = "999999";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gfa(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf<<value<<value<<value;;
        const char * result = "999999";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gfb(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf.push(value);
        const char * result = "127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gfc(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf<<value;
        const char * result = "127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gfd(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf.push(value).push(value).push(value);
        const char * result = "127127127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gfe(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf<<value<<value<<value;;
        const char * result = "127127127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gff(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf.push(value);
        const char * result = "-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gfg(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf<<value;
        const char * result = "-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gfh(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf.push(value).push(value).push(value);
        const char * result = "-128-128-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gfi(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf<<value<<value<<value;;
        const char * result = "-128-128-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gfj(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.pushf( "abc[%d]\n%s", 123, "acumon" );
        const char * result = "abc[123]\nacumon";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gga(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.pushf( "abc[%d]\n%s", 123, "acumon" ).pushf( "abc[%d]\n%s", 123, "acumon" ).pushf( "abc[%d]\n%s", 123, "acumon" );
        const char * result = "abc[123]\nacumonabc[123]\nacumonabc[123]\nacumon";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_ggb(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 3, 'a');
        const char * result = "aaa";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_ggc(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 0, 'a');
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_ggd(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "auto_buffer", 4 );
        const char * result = "auto";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gge(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "auto_buffer", 0 );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_ggf(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "", 0 );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_ggg(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "abc", 2 );
        const char * result = "ab";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_ggh(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( (const char *)(NULL) );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_ggi(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( (const char *)(NULL), 100 );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_ggj(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf << char(0);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gha(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( char(0) );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_ghb(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 10, char(0) );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_ghc(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 123 );
        buf.clear();
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_ghd(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.clear();
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_ghe(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf1.push(123);
        buf.transfer_from(buf1);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_ghf(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf.transfer_from(buf1);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_ghg(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push(123);
        Lsc::AutoBuffer buf1;
        buf1.transfer_from(buf);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_ghh(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf1.push(123);
        buf.transfer_from(buf1);
        buf1.push(123);
        buf.swap(buf1);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_ghi(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf.transfer_from(buf1);
        buf1.push(123);
        buf.swap(buf1);
        buf1.transfer_from(buf);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_ghj(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,1);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 1 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push(123);
        Lsc::AutoBuffer buf1;
        buf1.transfer_from(buf);
        buf.push(123);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gia(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf.push(value);
        const char * result = "true";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gib(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf<<value;
        const char * result = "true";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gic(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf.push(value).push(value).push(value);
        const char * result = "truetruetrue";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gid(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = true;
        buf<<value<<value<<value;;
        const char * result = "truetruetrue";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gie(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf.push(value);
        const char * result = "false";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gif(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf<<value;
        const char * result = "false";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gig(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf.push(value).push(value).push(value);
        const char * result = "falsefalsefalse";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gih(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        bool value = false;
        buf<<value<<value<<value;;
        const char * result = "falsefalsefalse";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gii(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf.push(value);
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gij(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf<<value;
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gja(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf.push(value).push(value).push(value);
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gjb(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        char value = 'c';
        buf<<value<<value<<value;;
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gjc(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf.push(value);
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gjd(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf<<value;
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gje(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf.push(value).push(value).push(value);
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gjf(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 0;
        buf<<value<<value<<value;;
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gjg(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf.push(value);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gjh(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf<<value;
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gji(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf.push(value).push(value).push(value);
        const char * result = "123123123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_gjj(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = 123;
        buf<<value<<value<<value;;
        const char * result = "123123123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_haa(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf.push(value);
        const char * result = "-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hab(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf<<value;
        const char * result = "-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hac(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf.push(value).push(value).push(value);
        const char * result = "-456-456-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_had(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        int value = -456;
        buf<<value<<value<<value;;
        const char * result = "-456-456-456";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hae(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf.push(value);
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_haf(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf<<value;
        const char * result = "0";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hag(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf.push(value).push(value).push(value);
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hah(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = 0;
        buf<<value<<value<<value;;
        const char * result = "000";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hai(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf.push(value);
        const char * result = "-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_haj(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf<<value;
        const char * result = "-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hba(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf.push(value).push(value).push(value);
        const char * result = "-1e+100-1e+100-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hbb(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        dolcle value = -1e+100;
        buf<<value<<value<<value;;
        const char * result = "-1e+100-1e+100-1e+100";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hbc(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value);
        const char * result = """";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hbd(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value;
        const char * result = """";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hbe(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value).push(value).push(value);
        const char * result = """""""";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hbf(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value<<value<<value;;
        const char * result = """""""";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hbg(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf.push(value);
        const char * result = "hello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hbh(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf<<value;
        const char * result = "hello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hbi(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf.push(value).push(value).push(value);
        const char * result = "hello worldhello worldhello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hbj(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "hello world";
        buf<<value<<value<<value;;
        const char * result = "hello worldhello worldhello world";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hca(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hcb(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value;
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hcc(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf.push(value).push(value).push(value);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hcd(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const char *  value = "";
        buf<<value<<value<<value;;
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hce(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf.push(value);
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hcf(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf<<value;
        const char * result = "c";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hcg(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf.push(value).push(value).push(value);
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hch(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        wchar_t value = L'c';
        buf<<value<<value<<value;;
        const char * result = "ccc";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hci(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf.push(value);
        const char * result = "hello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hcj(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf<<value;
        const char * result = "hello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hda(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf.push(value).push(value).push(value);
        const char * result = "hellohellohello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hdb(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        const wchar_t * value = L"hello";
        buf<<value<<value<<value;;
        const char * result = "hellohellohello";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hdc(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf.push(value);
        const char * result = "99";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hdd(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf<<value;
        const char * result = "99";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hde(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf.push(value).push(value).push(value);
        const char * result = "999999";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hdf(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        unsigned char value = 99;
        buf<<value<<value<<value;;
        const char * result = "999999";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hdg(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf.push(value);
        const char * result = "127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hdh(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf<<value;
        const char * result = "127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hdi(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf.push(value).push(value).push(value);
        const char * result = "127127127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hdj(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = 127;
        buf<<value<<value<<value;;
        const char * result = "127127127";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hea(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf.push(value);
        const char * result = "-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_heb(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf<<value;
        const char * result = "-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hec(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf.push(value).push(value).push(value);
        const char * result = "-128-128-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hed(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        signed char value = -128;
        buf<<value<<value<<value;;
        const char * result = "-128-128-128";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hee(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.pushf( "abc[%d]\n%s", 123, "acumon" );
        const char * result = "abc[123]\nacumon";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hef(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.pushf( "abc[%d]\n%s", 123, "acumon" ).pushf( "abc[%d]\n%s", 123, "acumon" ).pushf( "abc[%d]\n%s", 123, "acumon" );
        const char * result = "abc[123]\nacumonabc[123]\nacumonabc[123]\nacumon";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_heg(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 3, 'a');
        const char * result = "aaa";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_heh(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 0, 'a');
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hei(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "auto_buffer", 4 );
        const char * result = "auto";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hej(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "auto_buffer", 0 );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hfa(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "", 0 );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hfb(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( "abc", 2 );
        const char * result = "ab";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hfc(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( (const char *)(NULL) );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hfd(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( (const char *)(NULL), 100 );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hfe(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf << char(0);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hff(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( char(0) );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hfg(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 10, char(0) );
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hfh(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push( 123 );
        buf.clear();
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hfi(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.clear();
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hfj(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf1.push(123);
        buf.transfer_from(buf1);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hga(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf.transfer_from(buf1);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hgb(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push(123);
        Lsc::AutoBuffer buf1;
        buf1.transfer_from(buf);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hgc(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf1.push(123);
        buf.transfer_from(buf1);
        buf1.push(123);
        buf.swap(buf1);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hgd(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        Lsc::AutoBuffer buf1;
        buf.transfer_from(buf1);
        buf1.push(123);
        buf.swap(buf1);
        buf1.transfer_from(buf);
        const char * result = "";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


    void test_single_hge(){
        // init pool
        g_xmempool.create(g_membuf,sizeof(g_membuf));
        Lsc::AutoBuffer buf(g_xmempool,100);
        TS_ASSERT( buf.empty() );
        TS_ASSERT( !buf.truncated() );

        if ( 100 != 0 ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }


        buf.push(123);
        Lsc::AutoBuffer buf1;
        buf1.transfer_from(buf);
        buf.push(123);
        const char * result = "123";



        if ( 0 != strcmp( result, buf.c_str() ) ){
            see(buf.capacity());
            see(buf.size());
            see(strlen(result));
            see(buf.c_str());
            see(result);
        }
        TS_ASSERT( buf.size()  == strlen(result) );
        TS_ASSERT( buf.capacity() >= buf.size() );
        TS_ASSERT( 0 == strcmp( buf.c_str(), result ) );
        TS_ASSERT( !buf.truncated() );

        if ( buf.size() != 0 ){
            TS_ASSERT( !buf.empty() );
        }else{
            TS_ASSERT( buf.empty() );
        }

        if ( buf.size() != buf.capacity() ){
            TS_ASSERT( !buf.full() );
        }else{
            TS_ASSERT( buf.full() );
        }

        size_t old_capacity = buf.capacity();
        buf.clear();
        TS_ASSERT( buf.size() == 0 );
        TS_ASSERT( old_capacity == buf.capacity() );
        TS_ASSERT( buf.empty() );
        if ( old_capacity ){
            TS_ASSERT( !buf.full() );
        }
        g_xmempool.clear();

    }


};
#endif  //__BSL_TEST_AUTO_BUFFER_H_

